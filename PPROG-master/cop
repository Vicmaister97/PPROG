
colc functions: mult y algo

luego tenemos cop.h y cop.c que no saben nada de estas funciones pero que trabajan con ellas. cop.h está  incluido en calc.c y en cop.c ?
ni idea de esta parte

typedef double (*dfunct)(double,double);
podemos declarar variables entonces dfunct f1; es unpuntero a una función que coge dos doubles y devuelve un double.



double multi(double x,double y){
	return x*y;
}


dfunct f1;
f1=multi;
x=(*f1)(3.5,2.0);

struct{
	char *name;
	dfunck f;
}

compilamos cop.h cop.c y una vez hacemos calc.c lo utilizamos con esas funciones.

sin sentido hasta aquí



---------------------------------------------------------------------

live programming 


typedef double (*dfunk)(double, double)
typedef struct _cop cop;
cop *cop_create();
int cop_associate (cop *c, char *name, dfunk f);
double cop_execute(cop *c, charname, double x, double y);
/*Estas son las tres funciones básicas que necesitamos ahora mismo*/



---
#include <stdlib, malloc, string, cop.h>
ahora definimos la estructura que contendrá toda la información

typedef struct{
	char *name;
	defunck f;
} assoc;


struct _cop {
	int n_assoc;
	assoc *a;
} quiero saber cuantas asociaciones tengo y un array de asociaciones en las que guardo el nombre y el puntero a la funcion a la que hace referencia 

cop *cop_create(){
	cop *c=(cop *)malloc (sizeof(cop));
	c->n_assoc=0;
	c->a=NULL;
	return c;
}

int cop_associate(cop *c, char *name, dfunk f){
	creamos una nueva asociación
	assoc *ass = (assoc *)malloc (sizeof(asoc));
	ass->name = name;
	ass->f = f;
	ahora este name está ligado a la función f

	ahora falta meterlo en nuestro array y vamos a usar realloc (pointer, size)
	c->a=realloc(c->a,(c->n_assoc+1)*sizeof(assoc *));
	c->a[c->n_assoc++]=ass;

}


double cop_execute( cop *c, char *name, double x, double y){
	for(int i=0; i< c->n_assoc;i++){
	if(!strcmp(name, c->a[i]->name)){
		dfunk=g;
		g=c->a[i]->f
		return (*g)(x,y);
	} 
	return 0;

	}
}
